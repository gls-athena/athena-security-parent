# 工作流名称：CD - Master Branch Release
# 作用：在 master 分支推送或手动触发时，自动执行版本发布流程。
# 包括版本号计算、构建打包、生成 Release Notes、创建 GitHub Release、部署到 Maven 仓库等操作。

name: CD - Master Branch Release

# 触发条件配置
# 支持两种触发方式：
# 1. 当向 master 分支推送代码时自动触发；
# 2. 手动触发（workflow_dispatch），允许用户选择版本递增类型（patch/minor/major）。
on:
  push:
    branches: [ master ]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version increment type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major

# 权限配置：授予工作流对仓库内容、包、问题和拉取请求的写权限。
permissions:
  contents: write
  packages: write
  issues: write
  pull-requests: write

# 定义工作流中的任务（jobs）
jobs:
  # 任务名称：release
  # 功能：执行完整的发布流程，包括版本管理、构建、发布和部署。
  release:
    runs-on: ubuntu-latest

    steps:
      # 步骤1：检出代码
      # 使用 actions/checkout 检出整个 Git 历史以支持标签比较等操作。
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      # 步骤2：设置 JDK 环境
      # 配置 Java 21 环境，并启用 Maven 缓存以加速构建。
      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: '21'
          distribution: 'temurin'
          cache: maven

      # 步骤3：配置 Git 用户信息
      # 设置 Git 提交所需的全局用户信息。
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      # 步骤4：获取当前版本号
      # 从 pom.xml 中读取 revision 属性并去除 SNAPSHOT 后缀作为当前版本。
      - name: Get current version
        id: current_version
        run: |
          CURRENT_VERSION=$(mvn help:evaluate -Dexpression=revision -q -DforceStdout | sed 's/-SNAPSHOT//')
          echo "current=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      # 步骤5：计算下一个版本号
      # 根据用户输入的版本类型（major/minor/patch）计算发布版本与下一个开发版本。
      - name: Calculate next version
        id: next_version
        run: |
          CURRENT_VERSION="${{ steps.current_version.outputs.current }}"
          VERSION_TYPE="${{ github.event.inputs.version_type || 'patch' }}"
          
          # 当前版本就是要发布的版本（去掉SNAPSHOT后缀）
          RELEASE_VERSION="$CURRENT_VERSION"
          
          # 解析版本号用于计算下一个开发版本
          IFS='.' read -ra VERSION_PARTS <<< "$RELEASE_VERSION"
          MAJOR=${VERSION_PARTS[0]}
          MINOR=${VERSION_PARTS[1]}
          PATCH=${VERSION_PARTS[2]}
          
          # 根据类型递增版本来计算下一个开发版本
          case $VERSION_TYPE in
            "major")
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            "minor")
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            "patch")
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEXT_SNAPSHOT_VERSION="$MAJOR.$MINOR.$PATCH-SNAPSHOT"
          
          echo "next=$RELEASE_VERSION" >> $GITHUB_OUTPUT
          echo "next_snapshot=$NEXT_SNAPSHOT_VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $RELEASE_VERSION"
          echo "Next development version: $NEXT_SNAPSHOT_VERSION"

      # 步骤6：生成 Release Notes
      # 通过 Git 日志提取自上次发布以来的提交记录，用于生成 Release Notes。
      - name: Generate release notes from git log
        id: release_notes
        run: |
          # 获取上一个版本的标签
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_TAG" ]; then
            # 获取从上一个标签到当前HEAD的提交日志
            COMMITS=$(git log ${PREVIOUS_TAG}..HEAD --oneline --no-merges --format="- %s (%h)" | head -50)
            echo "Found commits since $PREVIOUS_TAG:"
            echo "$COMMITS"
          else
            # 如果没有找到上一个标签，获取最近的10个提交
            COMMITS=$(git log HEAD --oneline --no-merges --format="- %s (%h)" | head -10)
            echo "No previous tags found, showing recent commits:"
            echo "$COMMITS"
          fi
          
          # 保存到输出变量，处理多行文本
          {
            echo 'commits<<EOF'
            echo "$COMMITS"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          # 保存上一个版本信息
          echo "previous_tag=${PREVIOUS_TAG:-'Initial release'}" >> $GITHUB_OUTPUT

      # 步骤7：运行测试
      # 在发布前运行单元测试以确保代码质量。
      - name: Run tests before release
        run: |
          mvn clean test -Drevision=${{ steps.next_version.outputs.next }}

      # 步骤8：更新 pom.xml 中的 revision 属性为发布版本
      - name: Update revision property for release
        run: |
          # 更新 pom.xml 中的 revision 属性而不是 version
          sed -i "s/<revision>.*<\/revision>/<revision>${{ steps.next_version.outputs.next }}<\/revision>/g" pom.xml

      # 步骤9：构建并打包项目
      - name: Build and package
        run: |
          mvn clean package -DskipTests -Drevision=${{ steps.next_version.outputs.next }}

      # 步骤10：提交发布版本更改
      - name: Commit release version
        run: |
          git add .
          git commit -m "Release version ${{ steps.next_version.outputs.next }}" || echo "No changes to commit"

      # 步骤11：创建发布标签
      - name: Create release tag
        run: |
          git tag -a "v${{ steps.next_version.outputs.next }}" -m "Release version ${{ steps.next_version.outputs.next }}"

      # 步骤12：更新 pom.xml 中的 revision 属性为下一个开发版本
      - name: Update revision property for next development version
        run: |
          # 更新 revision 属性为下一个开发版本
          sed -i "s/<revision>.*<\/revision>/<revision>${{ steps.next_version.outputs.next_snapshot }}<\/revision>/g" pom.xml

      # 步骤13：提交下一个开发版本更改
      - name: Commit next development version
        run: |
          git add .
          git commit -m "Prepare for next development iteration ${{ steps.next_version.outputs.next_snapshot }}" || echo "No changes to commit"

      # 步骤14：推送更改和标签到远程仓库
      - name: Push changes and tags
        run: |
          git push origin master
          git push origin "v${{ steps.next_version.outputs.next }}"

      # 步骤15：将 master 的变更同步回 develop 分支（如果存在）
      - name: Sync changes back to develop branch
        run: |
          # 检查develop分支是否存在
          if git show-ref --verify --quiet refs/remotes/origin/develop; then
            echo "Develop branch exists, syncing changes..."
          
            # 切换到develop分支
            git checkout develop
            git pull origin develop
          
            # 合并master分支的变更到develop
            git merge master --no-ff -m "Sync release v${{ steps.next_version.outputs.next }} changes back to develop"
          
            # 推送develop分支
            git push origin develop
          
            echo "✅ Successfully synced changes to develop branch"
          else
            echo "⚠️ Develop branch does not exist, skipping sync"
          fi

      # 步骤16：创建 GitHub Release
      # 使用 GitHub CLI 创建一个带有 Release Notes 和依赖示例的 GitHub Release。
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # 创建临时文件存储release notes
          cat > release_notes.md << 'EOF'
          ## Release Notes for v${{ steps.next_version.outputs.next }}
          
          **Release Type:** ${{ github.event.inputs.version_type || 'patch' }} version increment
          **Previous Version:** ${{ steps.release_notes.outputs.previous_tag }}
          
          ### 🚀 What's Changed
          ${{ steps.release_notes.outputs.commits }}
          
          ### 📦 Artifacts
          This release includes all Maven modules in the athena-parent project.
          
          ### 💾 Installation
          ```xml
          <dependency>
              <groupId>io.github.gls-athena.security</groupId>
              <artifactId>athena-security-bom</artifactId>
              <version>${{ steps.next_version.outputs.next }}</version>
              <type>pom</type>
              <scope>import</scope>
          </dependency>
          ```
          
          ### 📝 Full Changelog
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${{ steps.release_notes.outputs.previous_tag }}...v${{ steps.next_version.outputs.next }}
          EOF
          
          # 使用文件创建release
          gh release create "v${{ steps.next_version.outputs.next }}" \
            --title "Release v${{ steps.next_version.outputs.next }}" \
            --notes-file release_notes.md

      # 步骤17：设置 GPG 环境（如果需要部署到 Maven 仓库）
      - name: Setup GPG for Maven deployment
        if: env.MAVEN_USERNAME != '' && env.MAVEN_PASSWORD != ''
        env:
          MAVEN_USERNAME: ${{ secrets.MAVEN_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.MAVEN_PASSWORD }}
          GPG_PRIVATE_KEY: ${{ secrets.GPG_PRIVATE_KEY }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ -n "$GPG_PRIVATE_KEY" ]; then
            echo "Setting up GPG for artifact signing..."
          
            # 导入 GPG 私钥
            echo "$GPG_PRIVATE_KEY" | gpg --batch --import --no-tty
          
            # 获取密钥 ID (修复版本)
            GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep -A1 "sec" | grep -E "^\s*[A-F0-9]+" | head -1 | awk '{print $1}' | cut -d'/' -f2)
          
            # 如果上面的方法失败，尝试另一种方法
            if [ -z "$GPG_KEY_ID" ]; then
              GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format LONG | grep "sec" | head -1 | sed 's/.*\/\([A-F0-9]*\).*/\1/')
            fi
          
            echo "GPG Key ID: $GPG_KEY_ID"
          
            # 配置 GPG 信任 (只有当获取到有效密钥 ID 时)
            if [ -n "$GPG_KEY_ID" ] && [ "$GPG_KEY_ID" != "" ]; then
              echo "$GPG_KEY_ID:6:" | gpg --import-ownertrust --no-tty
              echo "✅ GPG trust configured for key: $GPG_KEY_ID"
            else
              echo "⚠️ Could not extract GPG key ID, skipping trust configuration"
            fi
          
            # 测试 GPG 签名功能
            echo "test" | gpg --batch --yes --passphrase "$GPG_PASSPHRASE" --pinentry-mode loopback --sign --armor > /dev/null
          
            echo "✅ GPG setup completed successfully"
          else
            echo "⚠️ GPG_PRIVATE_KEY not found - GPG signing will be skipped"
          fi

      # 步骤18：部署到 Maven 仓库
      # 如果配置了 Maven 凭据，则将构建产物部署到指定的 Maven 仓库中。
      - name: Deploy to Maven Repository
        env:
          MAVEN_USERNAME: ${{ secrets.MAVEN_USERNAME }}
          MAVEN_PASSWORD: ${{ secrets.MAVEN_PASSWORD }}
          GPG_PASSPHRASE: ${{ secrets.GPG_PASSPHRASE }}
        run: |
          if [ -n "$MAVEN_USERNAME" ] && [ -n "$MAVEN_PASSWORD" ]; then
            echo "Deploying to Maven Repository..."
            mvn deploy -DskipTests -Drevision=${{ steps.next_version.outputs.next }} -Prelease \
              -s .github/settings.xml \
              -Dmaven.repo.username=$MAVEN_USERNAME \
              -Dmaven.repo.password=$MAVEN_PASSWORD \
              -Dgpg.passphrase=$GPG_PASSPHRASE
          else
            echo "Maven deployment skipped - credentials not configured"
          fi

  # 任务名称：notify
  # 功能：在 release 任务完成后发送通知（成功或失败）。
  notify:
    runs-on: ubuntu-latest
    needs: release
    if: always()

    steps:
      # 成功通知
      - name: Notify on success
        if: needs.release.result == 'success'
        run: |
          echo "✅ Release completed successfully!"
          echo "New version: v${{ needs.release.outputs.next_version }}"

      # 失败通知
      - name: Notify on failure
        if: needs.release.result == 'failure'
        run: |
          echo "❌ Release failed!"
          echo "Please check the logs and fix any issues."
